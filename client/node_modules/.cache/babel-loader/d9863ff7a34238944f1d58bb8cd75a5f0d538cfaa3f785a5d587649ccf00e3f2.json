{"ast":null,"code":"/*global Blob,File*/\n\n/**\n * Module requirements\n */\n\nvar isArray = require('isarray');\nvar isBuf = require('./is-buffer');\n\n/**\n * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.\n * Anything with blobs or files should be fed through removeBlobs before coming\n * here.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @api public\n */\n\nexports.deconstructPacket = function (packet) {\n  var buffers = [];\n  var packetData = packet.data;\n  function _deconstructPacket(data) {\n    if (!data) return data;\n    if (isBuf(data)) {\n      var placeholder = {\n        _placeholder: true,\n        num: buffers.length\n      };\n      buffers.push(data);\n      return placeholder;\n    } else if (isArray(data)) {\n      var newData = new Array(data.length);\n      for (var i = 0; i < data.length; i++) {\n        newData[i] = _deconstructPacket(data[i]);\n      }\n      return newData;\n    } else if ('object' == typeof data && !(data instanceof Date)) {\n      var newData = {};\n      for (var key in data) {\n        newData[key] = _deconstructPacket(data[key]);\n      }\n      return newData;\n    }\n    return data;\n  }\n  var pack = packet;\n  pack.data = _deconstructPacket(packetData);\n  pack.attachments = buffers.length; // number of binary 'attachments'\n  return {\n    packet: pack,\n    buffers: buffers\n  };\n};\n\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @api public\n */\n\nexports.reconstructPacket = function (packet, buffers) {\n  var curPlaceHolder = 0;\n  function _reconstructPacket(data) {\n    if (data && data._placeholder) {\n      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)\n      return buf;\n    } else if (isArray(data)) {\n      for (var i = 0; i < data.length; i++) {\n        data[i] = _reconstructPacket(data[i]);\n      }\n      return data;\n    } else if (data && 'object' == typeof data) {\n      for (var key in data) {\n        data[key] = _reconstructPacket(data[key]);\n      }\n      return data;\n    }\n    return data;\n  }\n  packet.data = _reconstructPacket(packet.data);\n  packet.attachments = undefined; // no longer useful\n  return packet;\n};\n\n/**\n * Asynchronously removes Blobs or Files from data via\n * FileReader's readAsArrayBuffer method. Used before encoding\n * data as msgpack. Calls callback with the blobless data.\n *\n * @param {Object} data\n * @param {Function} callback\n * @api private\n */\n\nexports.removeBlobs = function (data, callback) {\n  function _removeBlobs(obj, curKey, containingObject) {\n    if (!obj) return obj;\n\n    // convert any blob\n    if (global.Blob && obj instanceof Blob || global.File && obj instanceof File) {\n      pendingBlobs++;\n\n      // async filereader\n      var fileReader = new FileReader();\n      fileReader.onload = function () {\n        // this.result == arraybuffer\n        if (containingObject) {\n          containingObject[curKey] = this.result;\n        } else {\n          bloblessData = this.result;\n        }\n\n        // if nothing pending its callback time\n        if (! --pendingBlobs) {\n          callback(bloblessData);\n        }\n      };\n      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer\n    } else if (isArray(obj)) {\n      // handle array\n      for (var i = 0; i < obj.length; i++) {\n        _removeBlobs(obj[i], i, obj);\n      }\n    } else if (obj && 'object' == typeof obj && !isBuf(obj)) {\n      // and object\n      for (var key in obj) {\n        _removeBlobs(obj[key], key, obj);\n      }\n    }\n  }\n  var pendingBlobs = 0;\n  var bloblessData = data;\n  _removeBlobs(bloblessData);\n  if (!pendingBlobs) {\n    callback(bloblessData);\n  }\n};","map":{"version":3,"names":["isArray","require","isBuf","exports","deconstructPacket","packet","buffers","packetData","data","_deconstructPacket","placeholder","_placeholder","num","length","push","newData","Array","i","Date","key","pack","attachments","reconstructPacket","curPlaceHolder","_reconstructPacket","buf","undefined","removeBlobs","callback","_removeBlobs","obj","curKey","containingObject","global","Blob","File","pendingBlobs","fileReader","FileReader","onload","result","bloblessData","readAsArrayBuffer"],"sources":["C:/Users/gorapalli raju/chat-app/client/node_modules/socket.io-parser/binary.js"],"sourcesContent":["/*global Blob,File*/\n\n/**\n * Module requirements\n */\n\nvar isArray = require('isarray');\nvar isBuf = require('./is-buffer');\n\n/**\n * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.\n * Anything with blobs or files should be fed through removeBlobs before coming\n * here.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @api public\n */\n\nexports.deconstructPacket = function(packet){\n  var buffers = [];\n  var packetData = packet.data;\n\n  function _deconstructPacket(data) {\n    if (!data) return data;\n\n    if (isBuf(data)) {\n      var placeholder = { _placeholder: true, num: buffers.length };\n      buffers.push(data);\n      return placeholder;\n    } else if (isArray(data)) {\n      var newData = new Array(data.length);\n      for (var i = 0; i < data.length; i++) {\n        newData[i] = _deconstructPacket(data[i]);\n      }\n      return newData;\n    } else if ('object' == typeof data && !(data instanceof Date)) {\n      var newData = {};\n      for (var key in data) {\n        newData[key] = _deconstructPacket(data[key]);\n      }\n      return newData;\n    }\n    return data;\n  }\n\n  var pack = packet;\n  pack.data = _deconstructPacket(packetData);\n  pack.attachments = buffers.length; // number of binary 'attachments'\n  return {packet: pack, buffers: buffers};\n};\n\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @api public\n */\n\nexports.reconstructPacket = function(packet, buffers) {\n  var curPlaceHolder = 0;\n\n  function _reconstructPacket(data) {\n    if (data && data._placeholder) {\n      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)\n      return buf;\n    } else if (isArray(data)) {\n      for (var i = 0; i < data.length; i++) {\n        data[i] = _reconstructPacket(data[i]);\n      }\n      return data;\n    } else if (data && 'object' == typeof data) {\n      for (var key in data) {\n        data[key] = _reconstructPacket(data[key]);\n      }\n      return data;\n    }\n    return data;\n  }\n\n  packet.data = _reconstructPacket(packet.data);\n  packet.attachments = undefined; // no longer useful\n  return packet;\n};\n\n/**\n * Asynchronously removes Blobs or Files from data via\n * FileReader's readAsArrayBuffer method. Used before encoding\n * data as msgpack. Calls callback with the blobless data.\n *\n * @param {Object} data\n * @param {Function} callback\n * @api private\n */\n\nexports.removeBlobs = function(data, callback) {\n  function _removeBlobs(obj, curKey, containingObject) {\n    if (!obj) return obj;\n\n    // convert any blob\n    if ((global.Blob && obj instanceof Blob) ||\n        (global.File && obj instanceof File)) {\n      pendingBlobs++;\n\n      // async filereader\n      var fileReader = new FileReader();\n      fileReader.onload = function() { // this.result == arraybuffer\n        if (containingObject) {\n          containingObject[curKey] = this.result;\n        }\n        else {\n          bloblessData = this.result;\n        }\n\n        // if nothing pending its callback time\n        if(! --pendingBlobs) {\n          callback(bloblessData);\n        }\n      };\n\n      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer\n    } else if (isArray(obj)) { // handle array\n      for (var i = 0; i < obj.length; i++) {\n        _removeBlobs(obj[i], i, obj);\n      }\n    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object\n      for (var key in obj) {\n        _removeBlobs(obj[key], key, obj);\n      }\n    }\n  }\n\n  var pendingBlobs = 0;\n  var bloblessData = data;\n  _removeBlobs(bloblessData);\n  if (!pendingBlobs) {\n    callback(bloblessData);\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}