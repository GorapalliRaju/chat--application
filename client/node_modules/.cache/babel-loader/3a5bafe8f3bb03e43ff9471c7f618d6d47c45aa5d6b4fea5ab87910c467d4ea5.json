{"ast":null,"code":"/**\n * Module dependencies.\n */\n\nvar url = require('./url');\nvar parser = require('socket.io-parser');\nvar Manager = require('./manager');\nvar debug = require('debug')('socket.io-client');\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = lookup;\n\n/**\n * Managers cache.\n */\n\nvar cache = exports.managers = {};\n\n/**\n * Looks up an existing `Manager` for multiplexing.\n * If the user summons:\n *\n *   `io('http://localhost/a');`\n *   `io('http://localhost/b');`\n *\n * We reuse the existing instance based on same scheme/port/host,\n * and we initialize sockets for each namespace.\n *\n * @api public\n */\n\nfunction lookup(uri, opts) {\n  if (typeof uri === 'object') {\n    opts = uri;\n    uri = undefined;\n  }\n  opts = opts || {};\n  var parsed = url(uri);\n  var source = parsed.source;\n  var id = parsed.id;\n  var path = parsed.path;\n  var sameNamespace = cache[id] && path in cache[id].nsps;\n  var newConnection = opts.forceNew || opts['force new connection'] || false === opts.multiplex || sameNamespace;\n  var io;\n  if (newConnection) {\n    debug('ignoring socket cache for %s', source);\n    io = Manager(source, opts);\n  } else {\n    if (!cache[id]) {\n      debug('new io instance for %s', source);\n      cache[id] = Manager(source, opts);\n    }\n    io = cache[id];\n  }\n  if (parsed.query && !opts.query) {\n    opts.query = parsed.query;\n  } else if (opts && 'object' === typeof opts.query) {\n    opts.query = encodeQueryString(opts.query);\n  }\n  return io.socket(parsed.path, opts);\n}\n/**\n *  Helper method to parse query objects to string.\n * @param {object} query\n * @returns {string}\n */\nfunction encodeQueryString(obj) {\n  var str = [];\n  for (var p in obj) {\n    if (obj.hasOwnProperty(p)) {\n      str.push(encodeURIComponent(p) + '=' + encodeURIComponent(obj[p]));\n    }\n  }\n  return str.join('&');\n}\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = parser.protocol;\n\n/**\n * `connect`.\n *\n * @param {String} uri\n * @api public\n */\n\nexports.connect = lookup;\n\n/**\n * Expose constructors for standalone build.\n *\n * @api public\n */\n\nexports.Manager = require('./manager');\nexports.Socket = require('./socket');","map":{"version":3,"names":["url","require","parser","Manager","debug","module","exports","lookup","cache","managers","uri","opts","undefined","parsed","source","id","path","sameNamespace","nsps","newConnection","forceNew","multiplex","io","query","encodeQueryString","socket","obj","str","p","hasOwnProperty","push","encodeURIComponent","join","protocol","connect","Socket"],"sources":["C:/Users/gorapalli raju/chat-app/client/node_modules/socket.io-client/lib/index.js"],"sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar url = require('./url');\nvar parser = require('socket.io-parser');\nvar Manager = require('./manager');\nvar debug = require('debug')('socket.io-client');\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = lookup;\n\n/**\n * Managers cache.\n */\n\nvar cache = exports.managers = {};\n\n/**\n * Looks up an existing `Manager` for multiplexing.\n * If the user summons:\n *\n *   `io('http://localhost/a');`\n *   `io('http://localhost/b');`\n *\n * We reuse the existing instance based on same scheme/port/host,\n * and we initialize sockets for each namespace.\n *\n * @api public\n */\n\nfunction lookup (uri, opts) {\n  if (typeof uri === 'object') {\n    opts = uri;\n    uri = undefined;\n  }\n\n  opts = opts || {};\n\n  var parsed = url(uri);\n  var source = parsed.source;\n  var id = parsed.id;\n  var path = parsed.path;\n  var sameNamespace = cache[id] && path in cache[id].nsps;\n  var newConnection = opts.forceNew || opts['force new connection'] ||\n                      false === opts.multiplex || sameNamespace;\n\n  var io;\n\n  if (newConnection) {\n    debug('ignoring socket cache for %s', source);\n    io = Manager(source, opts);\n  } else {\n    if (!cache[id]) {\n      debug('new io instance for %s', source);\n      cache[id] = Manager(source, opts);\n    }\n    io = cache[id];\n  }\n  if (parsed.query && !opts.query) {\n    opts.query = parsed.query;\n  } else if (opts && 'object' === typeof opts.query) {\n    opts.query = encodeQueryString(opts.query);\n  }\n  return io.socket(parsed.path, opts);\n}\n/**\n *  Helper method to parse query objects to string.\n * @param {object} query\n * @returns {string}\n */\nfunction encodeQueryString (obj) {\n  var str = [];\n  for (var p in obj) {\n    if (obj.hasOwnProperty(p)) {\n      str.push(encodeURIComponent(p) + '=' + encodeURIComponent(obj[p]));\n    }\n  }\n  return str.join('&');\n}\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = parser.protocol;\n\n/**\n * `connect`.\n *\n * @param {String} uri\n * @api public\n */\n\nexports.connect = lookup;\n\n/**\n * Expose constructors for standalone build.\n *\n * @api public\n */\n\nexports.Manager = require('./manager');\nexports.Socket = require('./socket');\n"],"mappings":"AACA;AACA;AACA;;AAEA,IAAIA,GAAG,GAAGC,OAAO,CAAC,OAAO,CAAC;AAC1B,IAAIC,MAAM,GAAGD,OAAO,CAAC,kBAAkB,CAAC;AACxC,IAAIE,OAAO,GAAGF,OAAO,CAAC,WAAW,CAAC;AAClC,IAAIG,KAAK,GAAGH,OAAO,CAAC,OAAO,CAAC,CAAC,kBAAkB,CAAC;;AAEhD;AACA;AACA;;AAEAI,MAAM,CAACC,OAAO,GAAGA,OAAO,GAAGC,MAAM;;AAEjC;AACA;AACA;;AAEA,IAAIC,KAAK,GAAGF,OAAO,CAACG,QAAQ,GAAG,CAAC,CAAC;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASF,MAAMA,CAAEG,GAAG,EAAEC,IAAI,EAAE;EAC1B,IAAI,OAAOD,GAAG,KAAK,QAAQ,EAAE;IAC3BC,IAAI,GAAGD,GAAG;IACVA,GAAG,GAAGE,SAAS;EACjB;EAEAD,IAAI,GAAGA,IAAI,IAAI,CAAC,CAAC;EAEjB,IAAIE,MAAM,GAAGb,GAAG,CAACU,GAAG,CAAC;EACrB,IAAII,MAAM,GAAGD,MAAM,CAACC,MAAM;EAC1B,IAAIC,EAAE,GAAGF,MAAM,CAACE,EAAE;EAClB,IAAIC,IAAI,GAAGH,MAAM,CAACG,IAAI;EACtB,IAAIC,aAAa,GAAGT,KAAK,CAACO,EAAE,CAAC,IAAIC,IAAI,IAAIR,KAAK,CAACO,EAAE,CAAC,CAACG,IAAI;EACvD,IAAIC,aAAa,GAAGR,IAAI,CAACS,QAAQ,IAAIT,IAAI,CAAC,sBAAsB,CAAC,IAC7C,KAAK,KAAKA,IAAI,CAACU,SAAS,IAAIJ,aAAa;EAE7D,IAAIK,EAAE;EAEN,IAAIH,aAAa,EAAE;IACjBf,KAAK,CAAC,8BAA8B,EAAEU,MAAM,CAAC;IAC7CQ,EAAE,GAAGnB,OAAO,CAACW,MAAM,EAAEH,IAAI,CAAC;EAC5B,CAAC,MAAM;IACL,IAAI,CAACH,KAAK,CAACO,EAAE,CAAC,EAAE;MACdX,KAAK,CAAC,wBAAwB,EAAEU,MAAM,CAAC;MACvCN,KAAK,CAACO,EAAE,CAAC,GAAGZ,OAAO,CAACW,MAAM,EAAEH,IAAI,CAAC;IACnC;IACAW,EAAE,GAAGd,KAAK,CAACO,EAAE,CAAC;EAChB;EACA,IAAIF,MAAM,CAACU,KAAK,IAAI,CAACZ,IAAI,CAACY,KAAK,EAAE;IAC/BZ,IAAI,CAACY,KAAK,GAAGV,MAAM,CAACU,KAAK;EAC3B,CAAC,MAAM,IAAIZ,IAAI,IAAI,QAAQ,KAAK,OAAOA,IAAI,CAACY,KAAK,EAAE;IACjDZ,IAAI,CAACY,KAAK,GAAGC,iBAAiB,CAACb,IAAI,CAACY,KAAK,CAAC;EAC5C;EACA,OAAOD,EAAE,CAACG,MAAM,CAACZ,MAAM,CAACG,IAAI,EAAEL,IAAI,CAAC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,SAASa,iBAAiBA,CAAEE,GAAG,EAAE;EAC/B,IAAIC,GAAG,GAAG,EAAE;EACZ,KAAK,IAAIC,CAAC,IAAIF,GAAG,EAAE;IACjB,IAAIA,GAAG,CAACG,cAAc,CAACD,CAAC,CAAC,EAAE;MACzBD,GAAG,CAACG,IAAI,CAACC,kBAAkB,CAACH,CAAC,CAAC,GAAG,GAAG,GAAGG,kBAAkB,CAACL,GAAG,CAACE,CAAC,CAAC,CAAC,CAAC;IACpE;EACF;EACA,OAAOD,GAAG,CAACK,IAAI,CAAC,GAAG,CAAC;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA1B,OAAO,CAAC2B,QAAQ,GAAG/B,MAAM,CAAC+B,QAAQ;;AAElC;AACA;AACA;AACA;AACA;AACA;;AAEA3B,OAAO,CAAC4B,OAAO,GAAG3B,MAAM;;AAExB;AACA;AACA;AACA;AACA;;AAEAD,OAAO,CAACH,OAAO,GAAGF,OAAO,CAAC,WAAW,CAAC;AACtCK,OAAO,CAAC6B,MAAM,GAAGlC,OAAO,CAAC,UAAU,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}